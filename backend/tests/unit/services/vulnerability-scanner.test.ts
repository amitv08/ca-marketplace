/**
 * Unit Tests for Vulnerability Scanner Service
 */

import { VulnerabilityScannerService } from '../../../src/services/vulnerability-scanner.service';
import { exec } from 'child_process';
import { promisify } from 'util';

jest.mock('child_process');
const mockedExec = exec as jest.MockedFunction<typeof exec>;

describe('VulnerabilityScannerService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('runNpmAudit', () => {
    it('should parse npm audit results correctly', async () => {
      const mockAuditOutput = {
        vulnerabilities: {
          'test-package': {
            severity: 'high',
            via: [{ cve: 'CVE-2024-1234' }],
            effects: [],
            range: '1.0.0 - 2.0.0',
            nodes: [],
            fixAvailable: true,
          },
        },
      };

      const execAsync = promisify(exec);
      (execAsync as jest.Mock) = jest.fn().mockResolvedValue({
        stdout: JSON.stringify(mockAuditOutput),
      });

      const result = await VulnerabilityScannerService.runNpmAudit();

      expect(result.source).toBe('npm');
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.vulnerabilities[0].title).toContain('test-package');
    });

    it('should handle npm audit errors gracefully', async () => {
      const mockAuditOutput = {
        vulnerabilities: {
          'vulnerable-pkg': {
            severity: 'critical',
            via: [],
            effects: [],
            range: '1.0.0',
            nodes: [],
            fixAvailable: false,
          },
        },
      };

      const error = new Error('npm audit failed') as any;
      error.stdout = JSON.stringify(mockAuditOutput);

      const execAsync = promisify(exec);
      (execAsync as jest.Mock) = jest.fn().mockRejectedValue(error);

      const result = await VulnerabilityScannerService.runNpmAudit();

      expect(result.source).toBe('npm');
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
    });

    it('should map npm severity levels correctly', () => {
      const mapSeverity = (VulnerabilityScannerService as any).mapNpmSeverity;

      expect(mapSeverity('critical')).toBe('critical');
      expect(mapSeverity('high')).toBe('high');
      expect(mapSeverity('moderate')).toBe('medium');
      expect(mapSeverity('low')).toBe('low');
      expect(mapSeverity('unknown')).toBe('low');
    });
  });

  describe('runSnykScan', () => {
    const originalToken = process.env.SNYK_TOKEN;

    afterEach(() => {
      process.env.SNYK_TOKEN = originalToken;
    });

    it('should skip scan when SNYK_TOKEN is not configured', async () => {
      process.env.SNYK_TOKEN = 'your_snyk_api_token';

      const result = await VulnerabilityScannerService.runSnykScan();

      expect(result.source).toBe('snyk');
      expect(result.vulnerabilities.length).toBe(0);
    });

    it('should skip scan when SNYK_TOKEN is missing', async () => {
      delete process.env.SNYK_TOKEN;

      const result = await VulnerabilityScannerService.runSnykScan();

      expect(result.source).toBe('snyk');
      expect(result.vulnerabilities.length).toBe(0);
    });
  });

  describe('runTrivyScan', () => {
    const originalEnableTrivy = process.env.ENABLE_TRIVY_SCAN;

    afterEach(() => {
      process.env.ENABLE_TRIVY_SCAN = originalEnableTrivy;
    });

    it('should skip scan when Trivy is not enabled', async () => {
      process.env.ENABLE_TRIVY_SCAN = 'false';

      const result = await VulnerabilityScannerService.runTrivyScan();

      expect(result.source).toBe('trivy');
      expect(result.vulnerabilities.length).toBe(0);
    });

    it('should skip scan when ENABLE_TRIVY_SCAN is not set', async () => {
      delete process.env.ENABLE_TRIVY_SCAN;

      const result = await VulnerabilityScannerService.runTrivyScan();

      expect(result.source).toBe('trivy');
      expect(result.vulnerabilities.length).toBe(0);
    });
  });

  describe('deduplicateFindings', () => {
    it('should remove duplicate CVEs', () => {
      const findings = [
        {
          title: 'Finding 1',
          severity: 'high' as const,
          description: 'Test 1',
          affectedComponent: 'pkg1',
          recommendation: 'Fix 1',
          cve: 'CVE-2024-1234',
        },
        {
          title: 'Finding 2',
          severity: 'high' as const,
          description: 'Test 2',
          affectedComponent: 'pkg2',
          recommendation: 'Fix 2',
          cve: 'CVE-2024-1234', // Duplicate
        },
      ];

      const deduped = (VulnerabilityScannerService as any).deduplicateFindings(findings);

      expect(deduped.length).toBe(1);
      expect(deduped[0].cve).toBe('CVE-2024-1234');
    });

    it('should remove duplicates based on component and title when no CVE', () => {
      const findings = [
        {
          title: 'Missing Header',
          severity: 'high' as const,
          description: 'Test 1',
          affectedComponent: 'HTTP Headers',
          recommendation: 'Fix 1',
        },
        {
          title: 'Missing Header',
          severity: 'high' as const,
          description: 'Test 2',
          affectedComponent: 'HTTP Headers',
          recommendation: 'Fix 2',
        },
      ];

      const deduped = (VulnerabilityScannerService as any).deduplicateFindings(findings);

      expect(deduped.length).toBe(1);
    });

    it('should keep different vulnerabilities', () => {
      const findings = [
        {
          title: 'Finding 1',
          severity: 'high' as const,
          description: 'Test 1',
          affectedComponent: 'pkg1',
          recommendation: 'Fix 1',
          cve: 'CVE-2024-1234',
        },
        {
          title: 'Finding 2',
          severity: 'medium' as const,
          description: 'Test 2',
          affectedComponent: 'pkg2',
          recommendation: 'Fix 2',
          cve: 'CVE-2024-5678',
        },
      ];

      const deduped = (VulnerabilityScannerService as any).deduplicateFindings(findings);

      expect(deduped.length).toBe(2);
    });
  });

  describe('calculateSummary', () => {
    it('should correctly count vulnerabilities by severity', () => {
      const findings = [
        { severity: 'critical', title: '', description: '', affectedComponent: '', recommendation: '' },
        { severity: 'high', title: '', description: '', affectedComponent: '', recommendation: '' },
        { severity: 'high', title: '', description: '', affectedComponent: '', recommendation: '' },
        { severity: 'medium', title: '', description: '', affectedComponent: '', recommendation: '' },
        { severity: 'low', title: '', description: '', affectedComponent: '', recommendation: '' },
      ] as any[];

      const summary = (VulnerabilityScannerService as any).calculateSummary(findings);

      expect(summary.critical).toBe(1);
      expect(summary.high).toBe(2);
      expect(summary.medium).toBe(1);
      expect(summary.low).toBe(1);
      expect(summary.total).toBe(5);
    });

    it('should handle empty findings', () => {
      const summary = (VulnerabilityScannerService as any).calculateSummary([]);

      expect(summary.total).toBe(0);
      expect(summary.critical).toBe(0);
    });
  });

  describe('runFullScan', () => {
    it('should aggregate results from all scanners', async () => {
      // Mock all scanner methods to return empty results
      jest.spyOn(VulnerabilityScannerService, 'runNpmAudit').mockResolvedValue({
        source: 'npm',
        vulnerabilities: [],
      });

      jest.spyOn(VulnerabilityScannerService, 'runSnykScan').mockResolvedValue({
        source: 'snyk',
        vulnerabilities: [],
      });

      jest.spyOn(VulnerabilityScannerService, 'runTrivyScan').mockResolvedValue({
        source: 'trivy',
        vulnerabilities: [],
      });

      const result = await VulnerabilityScannerService.runFullScan();

      expect(result.scanType).toBe('VULNERABILITY_SCAN');
      expect(result.status).toBe('COMPLETED');
      expect(result.findings).toBeDefined();
      expect(result.summary).toBeDefined();
    });

    it('should handle scan failures gracefully', async () => {
      jest.spyOn(VulnerabilityScannerService, 'runNpmAudit').mockRejectedValue(new Error('Scan failed'));
      jest.spyOn(VulnerabilityScannerService, 'runSnykScan').mockRejectedValue(new Error('Scan failed'));
      jest.spyOn(VulnerabilityScannerService, 'runTrivyScan').mockRejectedValue(new Error('Scan failed'));

      const result = await VulnerabilityScannerService.runFullScan();

      expect(result.status).toBe('FAILED');
      expect(result.errorMessage).toBeDefined();
    });
  });

  describe('severity mapping', () => {
    it('should map Snyk severity correctly', () => {
      const mapSeverity = (VulnerabilityScannerService as any).mapSnykSeverity;

      expect(mapSeverity('critical')).toBe('critical');
      expect(mapSeverity('high')).toBe('high');
      expect(mapSeverity('medium')).toBe('medium');
      expect(mapSeverity('low')).toBe('low');
    });

    it('should map Trivy severity correctly', () => {
      const mapSeverity = (VulnerabilityScannerService as any).mapTrivySeverity;

      expect(mapSeverity('CRITICAL')).toBe('critical');
      expect(mapSeverity('HIGH')).toBe('high');
      expect(mapSeverity('MEDIUM')).toBe('medium');
      expect(mapSeverity('LOW')).toBe('low');
    });
  });
});
