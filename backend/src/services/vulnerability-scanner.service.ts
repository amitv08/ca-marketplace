import { exec } from 'child_process';
import { promisify } from 'util';
import { SecurityScanType, ScanStatus } from '@prisma/client';
import { SecurityFinding, SecurityScanResult, SecuritySummary } from './security-audit.service';

const execAsync = promisify(exec);

export interface NpmAuditResult {
  vulnerabilities: {
    [key: string]: {
      severity: string;
      via: any[];
      effects: string[];
      range: string;
      nodes: string[];
      fixAvailable: boolean;
    };
  };
  metadata: {
    vulnerabilities: {
      info: number;
      low: number;
      moderate: number;
      high: number;
      critical: number;
      total: number;
    };
  };
}

export interface VulnerabilityReport {
  source: 'npm' | 'snyk' | 'trivy';
  vulnerabilities: SecurityFinding[];
}

/**
 * Vulnerability Scanner Service
 * Scans for security vulnerabilities in dependencies
 */
export class VulnerabilityScannerService {
  // Cache results for 1 hour to avoid repeated scans
  private static cache: Map<string, { result: SecurityScanResult; timestamp: number }> = new Map();
  private static CACHE_TTL = 60 * 60 * 1000; // 1 hour

  /**
   * Run npm audit
   */
  static async runNpmAudit(): Promise<VulnerabilityReport> {
    try {
      // Run npm audit with JSON output
      const { stdout } = await execAsync('cd /app && npm audit --json', {
        maxBuffer: 1024 * 1024 * 10, // 10MB buffer
      });

      const auditResult: NpmAuditResult = JSON.parse(stdout);
      const vulnerabilities: SecurityFinding[] = [];

      // Parse vulnerabilities
      Object.entries(auditResult.vulnerabilities || {}).forEach(([packageName, vuln]) => {
        // Map npm severity to our severity levels
        const severity = this.mapNpmSeverity(vuln.severity);

        // Extract CVE information
        const cves: string[] = [];
        if (Array.isArray(vuln.via)) {
          vuln.via.forEach((v: any) => {
            if (typeof v === 'object' && v.cve) {
              cves.push(v.cve);
            }
          });
        }

        vulnerabilities.push({
          title: `Vulnerable dependency: ${packageName}`,
          severity,
          description: `Security vulnerability found in ${packageName}. Affected versions: ${vuln.range}`,
          affectedComponent: `npm package: ${packageName}`,
          recommendation: vuln.fixAvailable
            ? `Run 'npm audit fix' to update ${packageName}`
            : `Manually update ${packageName} to a secure version`,
          cve: cves.length > 0 ? cves.join(', ') : undefined,
        });
      });

      return {
        source: 'npm',
        vulnerabilities,
      };
    } catch (error: any) {
      // npm audit exits with code 1 if vulnerabilities found
      if (error.stdout) {
        try {
          const auditResult: NpmAuditResult = JSON.parse(error.stdout);
          const vulnerabilities: SecurityFinding[] = [];

          Object.entries(auditResult.vulnerabilities || {}).forEach(([packageName, vuln]) => {
            const severity = this.mapNpmSeverity(vuln.severity);

            const cves: string[] = [];
            if (Array.isArray(vuln.via)) {
              vuln.via.forEach((v: any) => {
                if (typeof v === 'object' && v.cve) {
                  cves.push(v.cve);
                }
              });
            }

            vulnerabilities.push({
              title: `Vulnerable dependency: ${packageName}`,
              severity,
              description: `Security vulnerability found in ${packageName}. Affected versions: ${vuln.range}`,
              affectedComponent: `npm package: ${packageName}`,
              recommendation: vuln.fixAvailable
                ? `Run 'npm audit fix' to update ${packageName}`
                : `Manually update ${packageName} to a secure version`,
              cve: cves.length > 0 ? cves.join(', ') : undefined,
            });
          });

          return {
            source: 'npm',
            vulnerabilities,
          };
        } catch (parseError) {
          console.error('Error parsing npm audit output:', parseError);
          return {
            source: 'npm',
            vulnerabilities: [],
          };
        }
      }

      console.error('Error running npm audit:', error.message);
      return {
        source: 'npm',
        vulnerabilities: [],
      };
    }
  }

  /**
   * Run Snyk scan (if SNYK_TOKEN is available)
   */
  static async runSnykScan(): Promise<VulnerabilityReport> {
    try {
      const snykToken = process.env.SNYK_TOKEN;

      if (!snykToken || snykToken === 'your_snyk_api_token') {
        console.log('Snyk token not configured, skipping Snyk scan');
        return {
          source: 'snyk',
          vulnerabilities: [],
        };
      }

      // Run Snyk test with JSON output
      const { stdout } = await execAsync(`cd /app && npx snyk test --json`, {
        env: { ...process.env, SNYK_TOKEN: snykToken },
        maxBuffer: 1024 * 1024 * 10,
      });

      const snykResult = JSON.parse(stdout);
      const vulnerabilities: SecurityFinding[] = [];

      // Parse Snyk vulnerabilities
      if (snykResult.vulnerabilities && Array.isArray(snykResult.vulnerabilities)) {
        snykResult.vulnerabilities.forEach((vuln: any) => {
          const severity = this.mapSnykSeverity(vuln.severity);

          vulnerabilities.push({
            title: `${vuln.title}`,
            severity,
            description: vuln.description || `Vulnerability in ${vuln.packageName}`,
            affectedComponent: `${vuln.packageName}@${vuln.version}`,
            recommendation: vuln.fixedIn && vuln.fixedIn.length > 0
              ? `Upgrade to version ${vuln.fixedIn[0]} or later`
              : 'No fix available yet. Monitor for updates.',
            cve: vuln.identifiers?.CVE?.join(', '),
            cwe: vuln.identifiers?.CWE?.join(', '),
          });
        });
      }

      return {
        source: 'snyk',
        vulnerabilities,
      };
    } catch (error: any) {
      // Snyk exits with non-zero code if vulnerabilities found
      if (error.stdout) {
        try {
          const snykResult = JSON.parse(error.stdout);
          const vulnerabilities: SecurityFinding[] = [];

          if (snykResult.vulnerabilities && Array.isArray(snykResult.vulnerabilities)) {
            snykResult.vulnerabilities.forEach((vuln: any) => {
              const severity = this.mapSnykSeverity(vuln.severity);

              vulnerabilities.push({
                title: `${vuln.title}`,
                severity,
                description: vuln.description || `Vulnerability in ${vuln.packageName}`,
                affectedComponent: `${vuln.packageName}@${vuln.version}`,
                recommendation: vuln.fixedIn && vuln.fixedIn.length > 0
                  ? `Upgrade to version ${vuln.fixedIn[0]} or later`
                  : 'No fix available yet. Monitor for updates.',
                cve: vuln.identifiers?.CVE?.join(', '),
                cwe: vuln.identifiers?.CWE?.join(', '),
              });
            });
          }

          return {
            source: 'snyk',
            vulnerabilities,
          };
        } catch (parseError) {
          console.error('Error parsing Snyk output:', parseError);
        }
      }

      console.error('Error running Snyk scan:', error.message);
      return {
        source: 'snyk',
        vulnerabilities: [],
      };
    }
  }

  /**
   * Run Trivy Docker image scan (if Docker is available)
   */
  static async runTrivyScan(): Promise<VulnerabilityReport> {
    try {
      const enableTrivy = process.env.ENABLE_TRIVY_SCAN === 'true';

      if (!enableTrivy) {
        console.log('Trivy scan not enabled, skipping');
        return {
          source: 'trivy',
          vulnerabilities: [],
        };
      }

      // Run Trivy scan on the backend image
      const { stdout } = await execAsync(
        `docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image --format json --severity CRITICAL,HIGH,MEDIUM ca_backend:latest`,
        {
          maxBuffer: 1024 * 1024 * 10,
        }
      );

      const trivyResult = JSON.parse(stdout);
      const vulnerabilities: SecurityFinding[] = [];

      // Parse Trivy results
      if (trivyResult.Results && Array.isArray(trivyResult.Results)) {
        trivyResult.Results.forEach((result: any) => {
          if (result.Vulnerabilities && Array.isArray(result.Vulnerabilities)) {
            result.Vulnerabilities.forEach((vuln: any) => {
              const severity = this.mapTrivySeverity(vuln.Severity);

              vulnerabilities.push({
                title: `${vuln.VulnerabilityID}: ${vuln.Title}`,
                severity,
                description: vuln.Description || `Vulnerability in ${vuln.PkgName}`,
                affectedComponent: `${vuln.PkgName}@${vuln.InstalledVersion}`,
                recommendation: vuln.FixedVersion
                  ? `Upgrade to version ${vuln.FixedVersion}`
                  : 'No fix available. Consider alternative packages.',
                cve: vuln.VulnerabilityID,
              });
            });
          }
        });
      }

      return {
        source: 'trivy',
        vulnerabilities,
      };
    } catch (error: any) {
      console.error('Error running Trivy scan:', error.message);
      return {
        source: 'trivy',
        vulnerabilities: [],
      };
    }
  }

  /**
   * Run full vulnerability scan (all sources)
   */
  static async runFullScan(): Promise<SecurityScanResult> {
    const startTime = Date.now();
    const startedAt = new Date();

    // Check cache
    const cacheKey = 'full_scan';
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      console.log('Returning cached vulnerability scan results');
      return cached.result;
    }

    try {
      // Run all scans in parallel
      const [npmReport, snykReport, trivyReport] = await Promise.allSettled([
        this.runNpmAudit(),
        this.runSnykScan(),
        this.runTrivyScan(),
      ]);

      // Aggregate findings
      const allVulnerabilities: SecurityFinding[] = [];

      if (npmReport.status === 'fulfilled') {
        allVulnerabilities.push(...npmReport.value.vulnerabilities);
      }

      if (snykReport.status === 'fulfilled') {
        allVulnerabilities.push(...snykReport.value.vulnerabilities);
      }

      if (trivyReport.status === 'fulfilled') {
        allVulnerabilities.push(...trivyReport.value.vulnerabilities);
      }

      // Deduplicate findings
      const dedupedVulnerabilities = this.deduplicateFindings(allVulnerabilities);

      const summary = this.calculateSummary(dedupedVulnerabilities);
      const duration = Date.now() - startTime;

      const result: SecurityScanResult = {
        scanType: SecurityScanType.VULNERABILITY_SCAN,
        status: ScanStatus.COMPLETED,
        findings: dedupedVulnerabilities,
        summary,
        startedAt,
        completedAt: new Date(),
        duration,
      };

      // Cache result
      this.cache.set(cacheKey, { result, timestamp: Date.now() });

      return result;
    } catch (error: any) {
      const duration = Date.now() - startTime;

      return {
        scanType: SecurityScanType.VULNERABILITY_SCAN,
        status: ScanStatus.FAILED,
        findings: [],
        summary: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
        startedAt,
        completedAt: new Date(),
        duration,
        errorMessage: error.message,
      };
    }
  }

  /**
   * Deduplicate findings by CVE and package name
   */
  private static deduplicateFindings(findings: SecurityFinding[]): SecurityFinding[] {
    const seen = new Set<string>();
    const deduped: SecurityFinding[] = [];

    findings.forEach((finding) => {
      const key = finding.cve
        ? finding.cve
        : `${finding.affectedComponent}_${finding.title}`;

      if (!seen.has(key)) {
        seen.add(key);
        deduped.push(finding);
      }
    });

    return deduped;
  }

  /**
   * Calculate summary from findings
   */
  private static calculateSummary(findings: SecurityFinding[]): SecuritySummary {
    const summary: SecuritySummary = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      total: findings.length,
    };

    findings.forEach((finding) => {
      summary[finding.severity]++;
    });

    return summary;
  }

  /**
   * Map npm severity to our severity levels
   */
  private static mapNpmSeverity(npmSeverity: string): 'critical' | 'high' | 'medium' | 'low' {
    const severity = npmSeverity.toLowerCase();

    switch (severity) {
      case 'critical':
        return 'critical';
      case 'high':
        return 'high';
      case 'moderate':
        return 'medium';
      case 'low':
        return 'low';
      default:
        return 'low';
    }
  }

  /**
   * Map Snyk severity to our severity levels
   */
  private static mapSnykSeverity(snykSeverity: string): 'critical' | 'high' | 'medium' | 'low' {
    const severity = snykSeverity.toLowerCase();

    switch (severity) {
      case 'critical':
        return 'critical';
      case 'high':
        return 'high';
      case 'medium':
        return 'medium';
      case 'low':
        return 'low';
      default:
        return 'low';
    }
  }

  /**
   * Map Trivy severity to our severity levels
   */
  private static mapTrivySeverity(trivySeverity: string): 'critical' | 'high' | 'medium' | 'low' {
    const severity = trivySeverity.toLowerCase();

    switch (severity) {
      case 'critical':
        return 'critical';
      case 'high':
        return 'high';
      case 'medium':
        return 'medium';
      case 'low':
        return 'low';
      default:
        return 'low';
    }
  }
}
