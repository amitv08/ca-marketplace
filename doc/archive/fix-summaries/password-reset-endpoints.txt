/**
 * BLOCKER #4 FIX: Password Reset Implementation
 *
 * REPLACE lines 266-299 in /backend/src/routes/auth.routes.secure.ts
 * with these three endpoints:
 */

// Add these imports at the top if not present:
import { LoggerService } from '../services/logger.service';
import { EmailTemplateService } from '../services/email-template.service';

/**
 * @route   POST /api/auth/reset-password/request
 * @desc    Request password reset (sends email with token)
 * @access  Public
 */
router.post(
  '/reset-password/request',
  rateLimiter,
  validateBody({
    email: { required: true, type: 'string' as const, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ },
  }),
  asyncHandler(async (req: Request, res: Response) => {
    const { email } = req.body;

    const user = await prisma.user.findFirst({
      where: { email: email.toLowerCase() },
    });

    // ALWAYS return success (prevent email enumeration)
    sendSuccess(
      res,
      null,
      'If an account with that email exists, a password reset link has been sent.'
    );

    if (user) {
      try {
        LoggerService.info(`Password reset requested for: ${user.email}`);

        // Generate reset token (valid 1 hour)
        const resetToken = TokenService.generateAccessToken(
          {
            userId: user.id,
            email: user.email,
            role: 'RESET',
          },
          '1h'
        );

        const resetExpiry = new Date();
        resetExpiry.setHours(resetExpiry.getHours() + 1);

        await prisma.passwordResetToken.create({
          data: {
            userId: user.id,
            token: resetToken,
            expiresAt: resetExpiry,
          },
        });

        const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3001'}/reset-password?token=${resetToken}`;

        await EmailTemplateService.sendPasswordReset({
          email: user.email,
          name: user.name,
          resetUrl,
          expiryHours: 1,
        });

        LoggerService.info(`✅ Password reset email sent to: ${user.email}`);
      } catch (error) {
        LoggerService.error('Failed to send password reset email', error as Error);
      }
    } else {
      LoggerService.warn(`Password reset requested for non-existent: ${email}`);
    }
  })
);

/**
 * @route   POST /api/auth/reset-password/verify
 * @desc    Verify reset token is valid
 * @access  Public
 */
router.post(
  '/reset-password/verify',
  validateBody({
    token: { required: true, type: 'string' as const },
  }),
  asyncHandler(async (req: Request, res: Response) => {
    const { token } = req.body;

    try {
      const decoded = TokenService.verifyToken(token);

      if (decoded.role !== 'RESET') {
        return sendError(res, 'Invalid reset token', 400);
      }

      const resetRecord = await prisma.passwordResetToken.findFirst({
        where: {
          token,
          expiresAt: { gte: new Date() },
          usedAt: null,
        },
      });

      if (!resetRecord) {
        return sendError(res, 'Reset token expired or invalid', 400);
      }

      sendSuccess(res, { valid: true, userId: decoded.userId });
    } catch (error) {
      return sendError(res, 'Invalid or expired reset token', 400);
    }
  })
);

/**
 * @route   POST /api/auth/reset-password/confirm
 * @desc    Reset password with valid token
 * @access  Public
 */
router.post(
  '/reset-password/confirm',
  rateLimiter,
  validateBody({
    token: { required: true, type: 'string' as const },
    newPassword: { required: true, type: 'string' as const, min: 12, max: 100 },
  }),
  asyncHandler(async (req: Request, res: Response) => {
    const { token, newPassword } = req.body;

    try {
      const decoded = TokenService.verifyToken(token);

      if (decoded.role !== 'RESET') {
        return sendError(res, 'Invalid reset token', 400);
      }

      const resetRecord = await prisma.passwordResetToken.findFirst({
        where: {
          token,
          userId: decoded.userId,
          expiresAt: { gte: new Date() },
          usedAt: null,
        },
      });

      if (!resetRecord) {
        return sendError(res, 'Reset token expired or already used', 400);
      }

      const user = await prisma.user.findUnique({
        where: { id: decoded.userId },
        include: {
          passwordHistory: {
            orderBy: { createdAt: 'desc' },
            take: 5,
          },
        },
      });

      if (!user) {
        return sendError(res, 'User not found', 404);
      }

      // Validate password strength
      const passwordValidation = PasswordValidator.validate(newPassword);
      if (!passwordValidation.isValid) {
        return sendError(res, passwordValidation.errors.join(', '), 400);
      }

      // Check password history
      for (const oldPassword of user.passwordHistory) {
        const isOldPassword = await bcrypt.compare(newPassword, oldPassword.passwordHash);
        if (isOldPassword) {
          return sendError(
            res,
            'Cannot reuse any of your last 5 passwords.',
            400
          );
        }
      }

      const hashedPassword = await bcrypt.hash(newPassword, 10);

      await prisma.$transaction(async (tx) => {
        await tx.user.update({
          where: { id: user.id },
          data: { password: hashedPassword },
        });

        await tx.passwordHistory.create({
          data: {
            userId: user.id,
            passwordHash: hashedPassword,
          },
        });

        await tx.passwordResetToken.update({
          where: { id: resetRecord.id },
          data: { usedAt: new Date() },
        });

        await tx.user.update({
          where: { id: user.id },
          data: { lastPasswordChangeAt: new Date() },
        });
      });

      try {
        await EmailTemplateService.sendPasswordChanged({
          email: user.email,
          name: user.name,
          changedAt: new Date(),
          ipAddress: req.ip || 'Unknown',
          loginUrl: `${process.env.FRONTEND_URL || 'http://localhost:3001'}/login`,
        });
      } catch (emailError) {
        LoggerService.error('Failed to send password change confirmation', emailError as Error);
      }

      LoggerService.info(`✅ Password reset successful for: ${user.email}`);
      sendSuccess(res, null, 'Password reset successfully. You can now login.');
    } catch (error: any) {
      LoggerService.error('Password reset failed', error);
      return sendError(res, 'Failed to reset password. Please request a new reset link.', 400);
    }
  })
);
