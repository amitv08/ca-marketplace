/**
 * BLOCKER #3 FIX: Payment Webhook Race Condition
 *
 * REPLACE lines 356-392 in /backend/src/routes/payment.routes.ts
 * with this code:
 */

// Razorpay webhook endpoint (NO AUTH - signature verified instead)
router.post('/webhook', asyncHandler(async (req: Request, res: Response) => {
  const webhookSignature = req.headers['x-razorpay-signature'] as string;
  const webhookSecret = process.env.RAZORPAY_WEBHOOK_SECRET;

  if (!webhookSecret) {
    console.error('RAZORPAY_WEBHOOK_SECRET not configured');
    return sendError(res, 'Webhook secret not configured', 500);
  }

  // Verify webhook signature
  const crypto = require('crypto');
  const expectedSignature = crypto
    .createHmac('sha256', webhookSecret)
    .update(JSON.stringify(req.body))
    .digest('hex');

  if (webhookSignature !== expectedSignature) {
    console.error('Invalid webhook signature');
    return sendError(res, 'Invalid signature', 400);
  }

  const event = req.body.event;
  const payload = req.body.payload;

  console.log('✅ Razorpay webhook verified:', event);

  // Handle different webhook events with idempotency
  try {
    switch (event) {
      case 'payment.captured':
        await handlePaymentCaptured(payload);
        break;

      case 'payment.failed':
        await handlePaymentFailed(payload);
        break;

      case 'refund.processed':
        await handleRefundProcessed(payload);
        break;

      default:
        console.log('Unhandled webhook event:', event);
    }

    sendSuccess(res, { received: true, event });
  } catch (error: any) {
    console.error('Webhook processing error:', error);
    sendSuccess(res, { received: true, error: error.message });
  }
}));

/**
 * Handle payment.captured webhook event with idempotency
 */
async function handlePaymentCaptured(payload: any) {
  const paymentEntity = payload.payment.entity;
  const orderId = paymentEntity.order_id;
  const razorpayPaymentId = paymentEntity.id;

  console.log(`Processing payment.captured: ${razorpayPaymentId} for order ${orderId}`);

  await prisma.$transaction(async (tx) => {
    const payment = await tx.payment.findFirst({
      where: { razorpayOrderId: orderId },
      include: {
        request: {
          include: {
            client: { include: { user: true } },
            ca: { include: { user: true } },
          },
        },
      },
    });

    if (!payment) {
      console.warn(`Payment not found for order ${orderId}`);
      return;
    }

    // IDEMPOTENCY CHECK
    if (payment.status === PaymentStatus.COMPLETED || payment.status === PaymentStatus.ESCROW_HELD) {
      console.log(`⚠️  Payment ${payment.id} already processed. Skipping.`);
      return;
    }

    await tx.payment.update({
      where: { id: payment.id },
      data: {
        status: PaymentStatus.COMPLETED,
        razorpayPaymentId,
        paidAt: new Date(),
      },
    });

    console.log(`✅ Payment ${payment.id} marked as COMPLETED`);

    if (payment.request.status === ServiceRequestStatus.PENDING) {
      await tx.serviceRequest.update({
        where: { id: payment.requestId },
        data: { status: ServiceRequestStatus.ACCEPTED },
      });
    }

    setImmediate(async () => {
      try {
        await EmailTemplateService.sendPaymentConfirmation({
          clientEmail: payment.request.client.user.email,
          clientName: payment.request.client.user.name,
          amount: payment.amount,
          caName: payment.request.ca?.user.name || 'the CA',
          serviceType: payment.request.serviceType,
          escrowReleaseDays: 7,
          dashboardUrl: `${process.env.FRONTEND_URL}/client/dashboard`,
        });
      } catch (emailError) {
        console.error('Failed to send payment confirmation email:', emailError);
      }
    });
  });
}

/**
 * Handle payment.failed webhook event
 */
async function handlePaymentFailed(payload: any) {
  const paymentEntity = payload.payment.entity;
  const orderId = paymentEntity.order_id;
  const errorDescription = paymentEntity.error_description || 'Payment failed';

  await prisma.$transaction(async (tx) => {
    const payment = await tx.payment.findFirst({
      where: { razorpayOrderId: orderId },
    });

    if (!payment) return;

    if (payment.status === PaymentStatus.FAILED) {
      console.log(`⚠️  Payment ${payment.id} already marked as FAILED. Skipping.`);
      return;
    }

    await tx.payment.update({
      where: { id: payment.id },
      data: {
        status: PaymentStatus.FAILED,
        failureReason: errorDescription,
      },
    });

    console.log(`✅ Payment ${payment.id} marked as FAILED`);
  });
}

/**
 * Handle refund.processed webhook event
 */
async function handleRefundProcessed(payload: any) {
  const refundEntity = payload.refund.entity;
  const paymentId = refundEntity.payment_id;
  const refundAmount = refundEntity.amount / 100;

  await prisma.$transaction(async (tx) => {
    const payment = await tx.payment.findFirst({
      where: { razorpayPaymentId: paymentId },
    });

    if (!payment) return;

    if (payment.status === PaymentStatus.REFUNDED && payment.refundAmount === refundAmount) {
      console.log(`⚠️  Refund already processed. Skipping.`);
      return;
    }

    await tx.payment.update({
      where: { id: payment.id },
      data: {
        status: refundAmount >= payment.amount ? PaymentStatus.REFUNDED : PaymentStatus.PARTIALLY_REFUNDED,
        refundAmount,
        refundedAt: new Date(),
      },
    });

    console.log(`✅ Refund processed: ₹${refundAmount}`);
  });
}
